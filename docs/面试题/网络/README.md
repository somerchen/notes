# 计算机网络面试题

## GET 和 POST 请求的区别

- 应用场景：GET 请求是一个幂等的请求，一般用来向服务器请求资源；POST 不是一个幂等的请求，一般用来发起会对服务器产生影响的请求如注册用户
- 是否缓存：浏览器一般会对 GET 请求缓存，但很少缓存 POST 请求
- 发送的报文格式：GET 请求的报文中实体部分一般都为空，POST 的请求报文中实体部分里一般都是向服务器发送的数据
- 安全性：GET 请求把参数都放到 url，会有安全隐患，因为请求的 url 会被放在历史记录中
- 请求长度：浏览器对于 url 长度的限制，会影响 GET 请求参数的长度，这个长度是浏览器决定的，不是 RFC 规定的
- 参数类型：POST 请求发送的参数支持更多的数据类型

## 常见的 HTTP 响应头和请求头

- Request Header
  - Accept: 浏览器能够处理的内容类型
  - Accept-Charset: 浏览器能够显示的字符集
  - Accept-Encoding: 浏览器能处理的压缩编码
  - Accept-Language: 浏览器当前设置的语言
  - Connection: 浏览器与服务器之间的连接类型
  - Cookie: 当前页面设置的 cookie
  - Host: 当前页面的所在域
  - Referer: 发出请求的页面 url
  - User-Agent: 浏览器的用户代理字符串
- Response Header
  - Date: 表示消息发送的时间
  - server: 服务器名称
  - Connection: 浏览器与服务器之间的连接类型
  - Cache-Control: 控制 HTTP 缓存
  - Content-Type: 表示后面的文档属于什么 MIME 类型

## http1.0 和 http1.1 之间有什么区别？

- 连接类型：http1.0 默认使用非持久连接，http1.1 默认使用持久连接。持久连接可以使多个 http 请求共用一个 TCP 连接，以此来避免每次连接都需要建立连接的延迟。
- 资源请求方面：http1.0 中存在浪费宽带的行为，例如客户端只需要一个对象的一部分，而服务器将整个对象传过来了，http1.1 新增了 range 请求头来限定要获取的范围，它允许只请求某个资源的一部分，返回码是 206，这样可以方便开发者自由选择，充分利用宽带和连接。
- 缓存方面 http1.0 中使用 if-modified-since、expires 来作为缓存判断的标准，http1.1 引入了更多的缓存控制策略，例如 Etag、if-unmodified-since、if-match、if-none-match 等缓存头
- http1.1 中新增了 host 字段，用来指定服务器域名 http1.0 中认为每台服务器都只有一个固定 ip，但随着虚拟主机的发展，一台服务器上会存在多个虚拟主机，对应着同一个 ip 地址，因此有了 host 字段，可以将请求发往统一服务器上的不同网站
- http1.1 相对于 http1.0 新增了很多请求方法(PUT, HEAD, OPTIONS...);

## HTTP1.1 和 HTTP2.0 之间的区别？

- 二进制协议：http2 是一个二进制协议。http1.1 中，头信息必须是文本，数据体可以是文本可以是二进制；http2 头信息和数据体都必须是二进制，并且统称为帧；帧的概念是实现多路复用的基础（通过将数据转化为二进制，并且在传输前将数据进行分帧，以帧为单位进行传输）。
- 多路复用：http2 实现了多路复用。http2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务端都可以同时发送多个请求，而不必按照顺序一一发送，这样就避免了队头阻塞的问题。
- 数据流：http2 使用了数据流的概念。http2 中请求是不按顺序发送的，一个连接里连续的数据包可能属于不同的请求，因此必须要对数据包做标记，指出它属于哪一个数据流。http2 将一个请求或回应的所有数据包称为数据流，每个数据流都有一个独一无二的编号。每个数据包发送时必须打上数据流编号，用来区分它属于哪个数据流。
- 头信息压缩：http2 实现了头信息压缩。http1.1 中是无状态的连接，每次请求都必须带上所有的信息，很多请求字段都是重复的，如 cookie，这样会浪费带宽，也会影响速度；http2 引入了头信息压缩机制，一方面头信息会压缩后再发送，另一方面客户端和服务器端共同维护一张头信息表，所有的字段都会存入这张表，生成一个索引 id，这样客服端只需要发送索引 id 就可以了。
- 服务器推送：http2 允许服务器未经请求，主动向客户端发送资源。这样可以相对减少一些延迟时间。需要注意的是 http2 主动推送的是静态资源，与 websocket 推送的即时信息是不同的。

## HTTP2 和 HTTP3 有什么区别？

http3 实现了真正的多路复用。http2 虽然能在一个 TCP 连接里同时发送多个请求，但是任何出现了丢包的数据流都必须等待该包重新传输后才能继续（http2 的多路复用特性对 TCP 的丢包恢复机制是不可见的，一个丢失或顺序不对的包会导致所有活动的事物暂停）；http3 和 http2 的主要区别在于使用的传输协议，http3 使用了 QUIC 协议，解决了 http2 因为 TCP 产生的队头阻塞问题。

> QUIC: 在 UDP 的基础上增加了一层来保证数据传输的可靠性，提供了数据包重传、拥塞控制等一些 TCP 中的特性。

## http 和 https 的区别

- https 需要证书，费用较高，http 不需要
- https 是加密传输，http 是明文传输
- https 是 443 端口，http 是 80 端口

## 当在浏览器中输入一个网址时发生了什么？

- 解析 url
- 缓存判断
- DNS 解析
- 获取 MAC 地址
- TCP 三次握手
- HTTPS 握手
- 返回数据
- 页面渲染
- TCP 四次挥手

## http 请求报文

- 请求行：方法、url、http 协议版本，用空格分隔，如 GET /index.html HTTP/1.1
- 请求头：由关键字/值对组成，每行一对，关键字和值由“:”分割
- 空行
- 请求体：post 等携带的数据

## http 响应报文

- 响应行：由 http 协议版本、状态码、原因短语组成，如 htpp/1.1 200 ok
- 响应头：响应部首
- 空行
- 响应体：服务器返回的数据

## 与缓存相关的 http 请求头有哪些？

- 强缓存：如果命中强缓存，则不需要给服务器发请求，直接使用缓存文件，是否使用缓存由响应头的 expires 或 cache-control 控制：
  - expires：一个表示绝对时间的字符串，会被客户端本身的时间影响
  - cache-control：常用 max-age 字段来控制文件的有效期是多久，如 cache-control:max-age=3600，优先级高于 expires
- 协商缓存：由服务端判断是否使用缓存，即存在一次通信。是否使用协商缓存由两队数据控制，他们总是成对出现。
  - last-modified、if-modified-since：表示文件最后的修改日期，响应头返回 last-modified，再次请求时请求头携带 if-modified-since，服务端判断资源是否有变化，返回 304 则代表使用缓存。
  - etag、if-none-match：表示资源是否有变化，一般由哈希表示，响应头返回 etag，再次请求时请求头携带 if-none-match。

> - etag 会优于 last-modified。当文件更改了但是内容没有变化时（仅仅改变修改时间），last-modified 并不能判断这种情况，而这时并不应该重新 GET；文件在一秒内多次修改时，last-modified 检查的粒度只能到秒，就会出现误差。
> - 优先级：cache-control > expires > etag > last-modified

## https 是如何保证安全的？

1. http 使用明文通信，存在安全隐患（信息窃听，信息篡改，信息劫持），https 经由 http 通信，利用 SSL/TLS（具有身份加密，信息加密，完整性校验）来加密数据包，保护交互数据的隐私与完整性。
2. TLS/SSL 安全协议的实现原理：
   1. **散列函数**验证信息的完整性
   2. **对称加密算法**采用协商的密钥对数据加密
   3. **非对称加密算法**实现身份认证和密钥协商
3. 再使用数字签名：需要一个安全的第三方颁发的证书。才能最大程度的保证通信安全。

## DNS 的解析过程

> DNS 是域名系统的缩写

- 当在浏览器输入一个网址时，会首先在浏览器缓存中查找对应的 IP 地址，找到直接返回，没找到则会向**本地 DNS 服务器**发送请求
- 本地 DNS 服务器在服务器缓存中先查找，没找到则向**根域名服务器**发起请求，根域名服务器返回一个查询域的顶级域名服务器地址
- 本地 DNS 服务器再向**顶级域名服务器**发起请求，顶级域名服务器先查看缓存，如没有则返回查询到的权威域名服务器地址
- 本地 DNS 服务器再向**权威域名服务器**发起请求，权威域名服务器返回对应的 ip 地址
- 本地 DNS 服务器把查询结果存入缓存
- 本地 DNS 服务器把查询结果告知浏览器

> 上面过程是迭代查询，与递归查询不同
> 递归查询：本地 DNS 服务器 <=> 根域名服务器 <=> 顶级域名服务器 <=> 权威域名服务器

## TCP 和 UDP 的区别

- UDP 不需要建立连接就可以直接发送消息，因此也是不可靠的，不能确保发送的消息一定被接收到；TCP 需要三次握手建立连接才能发送消息，也可靠的多，如果包丢失则会重传；
- UDP 发送消息的速率是恒定的，不会因为网络拥塞降低频率，因此适用于一些实时的场景，如直播，通话等；TCP 会因为网络拥塞降低发送频率；
- UDP 首部字节更小（8 字节），因此更快；TCP 则是 20-60 字节；
- UDP 支持一对一、一对多、多对一、多对多；TCP 只支持一对一；

## websocket 的理解

websocket 是基于 TCP 链接，并复用 http 的握手通道，客户端与服务端只需要进行一次握手就可以建立长久链接，并且互相发送消息。

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据
- 建立在 TCP 协议之上，服务端的实现比较容易
- 数据格式比较轻量，性能开销小，通信高效
- 没有同源限制，客户端可以与任意服务器通信
- 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL
- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

## TCP 三次握手和四次挥手

### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

第一次握手：建立连接时，客户端发送 syn 包（syn=x）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；

第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。

#### 为什么是三次握手，两次不行吗？

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常。

第一次握手：客户端发送网络包，服务端收到了。

这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。

这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。

这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

#### 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据

### 四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由 TCP 的半关闭（half-close）造成的。所谓的半关闭，其实就是 TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。

即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。

即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。

即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

#### 挥手为什么需要四次？

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文我收到了”。只有等到服务端所有的报文都发送完了，才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

#### 为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？

MSL(Maximum Segment Lifetime)是指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。

虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假想网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。
