<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 面试题 | cxb</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="notes">
    
    <link rel="preload" href="/notes/assets/css/0.styles.b9c09df2.css" as="style"><link rel="preload" href="/notes/assets/js/app.050c2602.js" as="script"><link rel="preload" href="/notes/assets/js/2.92902693.js" as="script"><link rel="preload" href="/notes/assets/js/10.f7e917bf.js" as="script"><link rel="prefetch" href="/notes/assets/js/11.c3ad8f74.js"><link rel="prefetch" href="/notes/assets/js/12.d912b401.js"><link rel="prefetch" href="/notes/assets/js/13.58f7275f.js"><link rel="prefetch" href="/notes/assets/js/14.d06ef76a.js"><link rel="prefetch" href="/notes/assets/js/15.1e751499.js"><link rel="prefetch" href="/notes/assets/js/16.19184a92.js"><link rel="prefetch" href="/notes/assets/js/17.8e8d3a08.js"><link rel="prefetch" href="/notes/assets/js/18.192b225f.js"><link rel="prefetch" href="/notes/assets/js/19.08cf1a1f.js"><link rel="prefetch" href="/notes/assets/js/20.adad8e88.js"><link rel="prefetch" href="/notes/assets/js/21.3b570bd9.js"><link rel="prefetch" href="/notes/assets/js/3.7d8837f1.js"><link rel="prefetch" href="/notes/assets/js/4.4466df2d.js"><link rel="prefetch" href="/notes/assets/js/5.02018b5a.js"><link rel="prefetch" href="/notes/assets/js/6.bd7b0c2a.js"><link rel="prefetch" href="/notes/assets/js/7.54f90aee.js"><link rel="prefetch" href="/notes/assets/js/8.6c8b8970.js"><link rel="prefetch" href="/notes/assets/js/9.83976a17.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.b9c09df2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">cxb</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/notes/面试题/" class="sidebar-heading clickable open"><span>面试题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/HTML/" class="sidebar-link">html 面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/CSS/" class="sidebar-link">CSS 面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/" aria-current="page" class="active sidebar-link">JS 面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#强类型语言与弱类型语言的区别" class="sidebar-link">强类型语言与弱类型语言的区别</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#js-的数据类型有哪些" class="sidebar-link">js 的数据类型有哪些？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#数据类型的检测有哪些" class="sidebar-link">数据类型的检测有哪些？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#判断数组的方法有哪些" class="sidebar-link">判断数组的方法有哪些？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#null-和-undefined-的区别" class="sidebar-link">null 和 undefined 的区别</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#typeof-null-的结果是什么-为什么" class="sidebar-link">typeof null 的结果是什么？为什么？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#instanceof-操作符的实现原理及实现" class="sidebar-link">instanceof 操作符的实现原理及实现</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#为什么-0-1-0-2-0-3-如何让其相等" class="sidebar-link">为什么 0.1+0.2 !== 0.3？如何让其相等？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#typeof-nan-的值是什么" class="sidebar-link">typeof NaN 的值是什么？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#操作符的强制类型转化规则" class="sidebar-link">== 操作符的强制类型转化规则</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#其他值到string的转换规则" class="sidebar-link">其他值到string的转换规则</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#其他值到number的转化规则" class="sidebar-link">其他值到number的转化规则</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#其他值到-boolean-的转化规则" class="sidebar-link">其他值到 boolean 的转化规则</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#object-is-和-、-区别" class="sidebar-link">Object.is 和 ==、=== 区别？</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#箭头函数与普通函数的区别" class="sidebar-link">箭头函数与普通函数的区别</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#扩展运算符" class="sidebar-link">扩展运算符</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#proxy-可以实现什么功能" class="sidebar-link">Proxy 可以实现什么功能</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#new-操作符" class="sidebar-link">new 操作符</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#map-和-object-的比较" class="sidebar-link">Map 和 Object 的比较</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#map-和-weakmap" class="sidebar-link">Map 和 weakMap</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#js-类数组对象的定义-如何转化为数组" class="sidebar-link">js 类数组对象的定义？如何转化为数组</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#原型与原型链" class="sidebar-link">原型与原型链</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#作用域-作用域链" class="sidebar-link">作用域/作用域链</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#settimeout-的-this-指向" class="sidebar-link">setTimeout 的 this 指向</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#事件循环与事件队列-eventloop" class="sidebar-link">事件循环与事件队列（EventLoop）</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#有哪些宏任务-哪些微任务" class="sidebar-link">有哪些宏任务，哪些微任务</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#异步编程" class="sidebar-link">异步编程</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#面向对象" class="sidebar-link">面向对象</a></li><li class="sidebar-sub-header"><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/JS/#es6-有什么更新" class="sidebar-link">ES6 有什么更新</a></li></ul></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/TS/" class="sidebar-link">TS</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/React/" class="sidebar-link">React 面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/Vue/" class="sidebar-link">Vue 面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/Webpack/" class="sidebar-link">Webpack 面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C/" class="sidebar-link">计算机网络面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="sidebar-link">设计模式面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="sidebar-link">浏览器相关面试题</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/" class="sidebar-link">手写系列</a></li><li><a href="/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%80%9A%E7%94%A8/" class="sidebar-link">通用面试题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-面试题"><a href="#js-面试题" class="header-anchor">#</a> JS 面试题</h1> <h2 id="强类型语言与弱类型语言的区别"><a href="#强类型语言与弱类型语言的区别" class="header-anchor">#</a> 强类型语言与弱类型语言的区别</h2> <ul><li>强类型语言：也就是强制必须定义变量类型的语言，变量的使用需要符合类型定义，所有变量如果不进行强制类型转换，那么就永远是一种类型。</li> <li>弱语言类型：是一种变量类型可以忽略的语言，js 就是弱语言类型，在 js 中，如果变量不符合要求会进行强制类型转化</li> <li>区别：强类型语言速度可能略逊色于弱语言类型，但是带来的严谨性可以帮助避免许多错误</li></ul> <h2 id="js-的数据类型有哪些"><a href="#js-的数据类型有哪些" class="header-anchor">#</a> js 的数据类型有哪些？</h2> <p>js 共有 8 种数据类型，其中：</p> <ul><li>引用类型：<code>object</code></li> <li>原始数据类型：<code>null</code> <code>undefined</code> <code>boolean</code> <code>number</code> <code>string</code> <code>symbol</code> <code>bigInt</code></li></ul> <h2 id="数据类型的检测有哪些"><a href="#数据类型的检测有哪些" class="header-anchor">#</a> 数据类型的检测有哪些？</h2> <ul><li>typeof：数组、null、对象都会被识别为 object，其他都正确</li> <li>instanceof：只能正确的判断引用数据类型</li> <li>constructor：<code>(type).constructor.name.toLowerCase()</code>，如果原型被修改过就不能判断</li> <li><code>Object.prototype.toString.call()</code></li></ul> <h2 id="判断数组的方法有哪些"><a href="#判断数组的方法有哪些" class="header-anchor">#</a> 判断数组的方法有哪些？</h2> <ul><li><code>Object.prototype.toString.call()</code></li> <li>原型链：<code>arr.__proto__ === Array.prototype</code></li> <li><code>Array.isArray(arr)</code></li> <li>instanceof</li> <li><code>Array.prototype.isPrototypeOf(arr)</code></li></ul> <h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="header-anchor">#</a> null 和 undefined 的区别</h2> <p>null 和 undefined 两个基本类型都只有一个值，就是 null 和 undefined。
undefined 的含义是未定义，null 的含义是空对象。变量声明了但未赋值时默认就是 undefined，null 则是常用于赋值给一些可能会返回对象的变量作为初始值。</p> <h2 id="typeof-null-的结果是什么-为什么"><a href="#typeof-null-的结果是什么-为什么" class="header-anchor">#</a> typeof null 的结果是什么？为什么？</h2> <p>结果是 object。
这是 js 的历史遗留问题。早期的 javascript 的值是包含一个<strong>类型标签</strong>的，object 的类型标签是 000，null 的值也全是 0，所以 null 会被判定为 object。</p> <h2 id="instanceof-操作符的实现原理及实现"><a href="#instanceof-操作符的实现原理及实现" class="header-anchor">#</a> instanceof 操作符的实现原理及实现</h2> <p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现对象的原型链中的任何位置。</p> <h2 id="为什么-0-1-0-2-0-3-如何让其相等"><a href="#为什么-0-1-0-2-0-3-如何让其相等" class="header-anchor">#</a> 为什么 0.1+0.2 !== 0.3？如何让其相等？</h2> <p>因为 js 的数字类型是根据 IEEE754 标准实现的，使用 64 位固定长度表示。而小数在转化成二进制后，会根据长度保留有效数字，遵循“0 舍 1 入”的原则。所以难免会有误差。</p> <p>而要解决误差，最直接的就是设置一个误差范围，对 js 来说，这个误差范围在<code>Number.EPSILON</code>内，就可以认为是相等的。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>还有一种就是把所有的小数转为整数计算后再变为小数</p> <h2 id="typeof-nan-的值是什么"><a href="#typeof-nan-的值是什么" class="header-anchor">#</a> typeof NaN 的值是什么？</h2> <p>number</p> <p>NaN 是一个特殊值，它和自身不相等是唯一一个 <code>x === x</code> 不成立的值。
要判断是否是 NaN，可以使用<code>isNaN</code>或<code>Number.isNaN</code></p> <ul><li><code>isNaN</code>：接收参数后，会把参数转为数值，再判断是否是<code>NaN</code></li> <li><code>Number.isNaN</code>会先判断参数是否是数字，如果是再判断是否是<code>NaN</code></li></ul> <h2 id="操作符的强制类型转化规则"><a href="#操作符的强制类型转化规则" class="header-anchor">#</a> == 操作符的强制类型转化规则</h2> <p><code>==</code> 会先判断左右两侧的变量类型是否相同，如果相同则比较值大小，如果不同，则会进行强制类型转化</p> <ol><li>双方是否是 <code>null</code> 和 <code>undefined</code>，如是，返回<code>true</code></li> <li>判断两者类型是否是 <code>string</code> 和 <code>number</code>，如果是则把 <code>string</code> 转化为<code>number</code></li> <li>如果一方是<code>boolean</code>，则会把<code>boolean</code>转化为<code>number</code>再比较</li> <li>如果一方是<code>object</code>，另一方是<code>string</code>，<code>number</code>，<code>symbol</code>，则把<code>object</code>转化为原始类型再比较</li></ol> <blockquote><p>symbol 不会进行隐式类型转换，只能显示的进行类型转换，但是 == 的另一方可以隐式转换</p></blockquote> <h2 id="其他值到string的转换规则"><a href="#其他值到string的转换规则" class="header-anchor">#</a> 其他值到<code>string</code>的转换规则</h2> <ul><li>null -&gt; 'null'</li> <li>undefined -&gt; 'undefined'</li> <li>boolean: true -&gt; 'true', false -&gt; 'false'</li> <li>number: 直接转化，但是极大和极小的数会用指数形式</li> <li>symbol: 直接转化，但是只能显式转化</li> <li>object: 先尝试 Symbol.toPrimitive 再 toString 再 valueOf，直到某一个方法返回原始值，如原始值不是字符串再按上述方法转化</li></ul> <h2 id="其他值到number的转化规则"><a href="#其他值到number的转化规则" class="header-anchor">#</a> 其他值到<code>number</code>的转化规则</h2> <ul><li>null -&gt; 0</li> <li>undefined -&gt; NaN</li> <li>boolean: true -&gt; 1, false -&gt; 0</li> <li>string: 使用 Number() 方法转换，包含非数字字符串则为 NaN，空字符串为 0</li> <li>symbol: 不能转换为 number，会报错</li> <li>object: 先尝试 Symbol.toPrimitive 再 valueOf 再 toString，直到某一个方法返回原始值，如原始值不是数字再按上述方法转化</li></ul> <h2 id="其他值到-boolean-的转化规则"><a href="#其他值到-boolean-的转化规则" class="header-anchor">#</a> 其他值到 boolean 的转化规则</h2> <ul><li>0, +0, -0, NaN, '', null, undefined 会转化为 false</li> <li>其他都转化为 true</li></ul> <h2 id="object-is-和-、-区别"><a href="#object-is-和-、-区别" class="header-anchor">#</a> Object.is 和 ==、=== 区别？</h2> <ul><li>== 判断时如果双方类型不同，会先转化类型再比较</li> <li>=== 如果双方类型不同，会直接返回 false</li> <li>Object.is 大致上与 === 相似，但是做了其他处理，+0 和 -0 不再相同，NaN 会等于 NaN</li></ul> <h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="header-anchor">#</a> 箭头函数与普通函数的区别</h2> <ul><li>箭头函数更简洁</li> <li>箭头函数没有 this，它只会在自己作用域的上一层继承 this，所以它的 this 在定义的时候就固定了，后续不会再更改。call、apply、bing 不能改变箭头函数的 this 指向</li> <li>箭头函数不能作为构造函数，没有 prototype 属性</li> <li>箭头函数不能 Generator 函数，不能用 yield 关键字</li> <li>箭头函数没有 arguments</li></ul> <h2 id="扩展运算符"><a href="#扩展运算符" class="header-anchor">#</a> 扩展运算符</h2> <ul><li>扩展运算符用于取出对象中的可遍历属性，拷贝到新对象中，与 Object.assign 作用相同</li> <li>数组也和对象一样使用扩展运算符</li> <li>rest 参数：把一个分离的序列整合成一个数组/对象，可用于解构，函数参数</li></ul> <h2 id="proxy-可以实现什么功能"><a href="#proxy-可以实现什么功能" class="header-anchor">#</a> Proxy 可以实现什么功能</h2> <p>Proxy 接收两个参数，一个是要代理的对象，一个是处理器，我们可以在处理器中添加 get 和 set，可以在获取与修改值时做额外的事情。</p> <p>Vue3 就是根据 Proxy 来实现依赖收集和派发的。</p> <p>与 Object.defineProperty 相比，Proxy 无需一层层的为每个属性添加代理，一次就能完成所有工作，且可以监听到任何形式的更改，缺点是老旧的浏览器会不支持。</p> <h2 id="new-操作符"><a href="#new-操作符" class="header-anchor">#</a> new 操作符</h2> <ol><li>首先创建一个空对象</li> <li>把空对象的原型设置为构造函数的 prototype</li> <li>把函数的 this 指向这个空对象</li> <li>执行构造函数</li> <li>判断函数的返回类型，如果是原始值则返回创建的这个对象，如果是引用类型则返回这个引用</li></ol> <h2 id="map-和-object-的比较"><a href="#map-和-object-的比较" class="header-anchor">#</a> Map 和 Object 的比较</h2> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">Map</th> <th style="text-align:center;">Object</th></tr></thead> <tbody><tr><td style="text-align:center;">意外的键</td> <td style="text-align:center;">Map 默认情况下不包含任何键，只包含显示插入的键</td> <td style="text-align:center;">Object 的原型上可能存在和本身相同的键</td></tr> <tr><td style="text-align:center;">键的类型</td> <td style="text-align:center;">任何类型</td> <td style="text-align:center;">字符串和 symbol</td></tr> <tr><td style="text-align:center;">键的顺序</td> <td style="text-align:center;">有序的，遍历时会按插入顺序遍历</td> <td style="text-align:center;">无序的</td></tr> <tr><td style="text-align:center;">size</td> <td style="text-align:center;">使用 size 属性获取</td> <td style="text-align:center;">只能手动计算</td></tr> <tr><td style="text-align:center;">迭代</td> <td style="text-align:center;">Map 是 iterable 的，可以直接迭代</td> <td style="text-align:center;">使用 Object.keys()获取 key 组成的数组后才能迭代</td></tr> <tr><td style="text-align:center;">性能</td> <td style="text-align:center;">在频繁插入删除的时候表现更好，有特殊的优化</td> <td style="text-align:center;">没有优化</td></tr></tbody></table> <h2 id="map-和-weakmap"><a href="#map-和-weakmap" class="header-anchor">#</a> Map 和 weakMap</h2> <ul><li>拥有的属性、方法不同
<ul><li>Map: size, has, get, set, delete, clear, keys, values, entries, forEach</li> <li>weakMap: has, get, set, delete</li></ul></li> <li>键的类型不同
<ul><li>Map: 任意类型</li> <li>weakMap: 对象类型</li></ul></li> <li>对键的引用类型不同
<ul><li>Map: 键是对象时，即使外部没有了这个对象的引用，也不会被垃圾回收</li> <li>weakMap: 当外界失去了对键的引用，那么 weakMap 的键会被垃圾回收机制回收，所以 weakMap 没有 keys, values, entries, forEach 等遍历方法，它的键值随时会变化</li></ul></li></ul> <h2 id="js-类数组对象的定义-如何转化为数组"><a href="#js-类数组对象的定义-如何转化为数组" class="header-anchor">#</a> js 类数组对象的定义？如何转化为数组</h2> <p>定义：一个拥有 length 属性且有一系列索引属性的对象都可以称为类数组对象</p> <p>转化方法：</p> <ul><li>Array.prototype.slice.call(arrayLike) // 不会改变原对象</li> <li>Array.prototype.splice.call(arrayLike, 0) // 会改变原对象</li> <li>Array.from(arrayLike) // 不会改变原对象</li></ul> <p>如何遍历类数组：</p> <ul><li>将数组方法应用到类数组上</li> <li>转化为数组</li></ul> <h2 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h2> <p>当使用构造函数新建对象时</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>p 被称为<strong>实例</strong>，P 被称为<strong>构造函数</strong>，构造函数的 <code>prototype</code> 属性被称为<strong>原型对象</strong>。</p> <p>实例是一个对象，当访问一个实例上不存在的属性时，js 会去实例的原型上查找，实例的原型指向<strong>原型对象</strong>。</p> <p>当实例的原型上也找不到这个属性时，js 会去实例的原型的原型上去查找，也就是<strong>原型对象</strong>自己的原型，直到<code>Object.prototype</code>为止。</p> <p>一个实例，可以通过<code>__proto__</code>属性来查看自己的原型，<code>Object.prototype.__proto__</code>是<code>null</code>，这也是<code>Object.prototype</code>被认为是原型链的终点的原因。</p> <p>默认情况下，原型对象只有一个 constructor 属性，这个属性指向构造函数本身。</p> <h2 id="作用域-作用域链"><a href="#作用域-作用域链" class="header-anchor">#</a> 作用域/作用域链</h2> <ul><li>作用域分为全局作用域、函数作用域、块作用域</li> <li>作用域链是指在当前作用域使用的变量未定义时，会去上一级的作用域查找，直到全局作用域找到变量/报错</li></ul> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>是指能在函数外部访问函数内部变量的函数</p> <h2 id="this"><a href="#this" class="header-anchor">#</a> this</h2> <p>this 是执行上下文的一个属性，他指向最后一个调用这个方法的对象</p> <ul><li>函数调用：当一个函数不是对象的属性，直接作为函数来调用时，函数内部的 this 在非严格模式下指向全局对象，严格模式下指向 undefined</li> <li>方法调用：当一个函数作为一个对象的属性方法来调用时，this 指向这个函数</li> <li>构造函数调用：函数用 new 调用时，函数会先创建一个对象，this 指向这个对象</li> <li>apply/call/bind: 这三个方法都可以改变函数的 this 指向
<ul><li>apply 接收两个参数，第一个是 this 要指向的对象，第二个是函数参数组成的数组</li> <li>call 接受的第一个参数是 this 要指向的对象，其他的参数都会被作为函数参数传入函数</li> <li>bind 返回一个绑定了 this 值的新函数，这个函数的 this 指向除了使用 new 时会改变，其他时候都不会变</li></ul></li></ul> <blockquote><p>这四种方法，优先级从高到低是 构造函数调用 &gt; apply/call/bind &gt; 方法调用 &gt; 函数调用</p></blockquote> <h2 id="settimeout-的-this-指向"><a href="#settimeout-的-this-指向" class="header-anchor">#</a> setTimeout 的 this 指向</h2> <ul><li>如果是个普通回调函数，则 this 会被挂载到 window</li> <li>如果是个箭头函数，则 this 会被指向定义时的作用域 this 指向</li></ul> <h2 id="事件循环与事件队列-eventloop"><a href="#事件循环与事件队列-eventloop" class="header-anchor">#</a> 事件循环与事件队列（EventLoop）</h2> <p>js 是单线程执行的，大多数时候都是从上到下执行代码，但是当遇到异步代码时，会根据异步函数的类别是宏任务还是微任务，加入到不同事件队列中，直到当前同步任务执行完毕，js 会检查微任务队列是否有待执行的微任务，然后依次执行，直到微任务队列清空，视情况渲染页面。然后继续检查宏任务队列，执行宏任务...循环往复直到所有队列清空。</p> <h2 id="有哪些宏任务-哪些微任务"><a href="#有哪些宏任务-哪些微任务" class="header-anchor">#</a> 有哪些宏任务，哪些微任务</h2> <ul><li>宏任务
<ul><li>script</li> <li>setTimeout</li> <li>setInterval</li> <li>postMessage</li> <li>MessageChannel</li> <li>UI 交互事件</li> <li>setImmediate(node)</li></ul></li> <li>微任务
<ul><li>Promise</li> <li>MutationObserver</li> <li>process.nextTick(node)</li></ul></li></ul> <h2 id="异步编程"><a href="#异步编程" class="header-anchor">#</a> 异步编程</h2> <ul><li>回调函数：回调地狱</li> <li>promise: 可以把回调形式改为链式调用</li> <li>generator: 一种在函数执行过程中，可以把执行权转移出去，函数外部还可以把执行权转移回来。在遇到异步函数执行时，把函数执行权转移异步函数，异步函数执行完再把执行权转移回来。因此可以像写同步代码一样处理异步操作。
<blockquote><p>控制权的转移是个问题 <br>
理解起来很困难</p></blockquote></li> <li>async/await: 是 generator 和 promise 实现的一个语法糖。await 要和 async 搭配使用，await 后面接收一个 promise，它会等待 promise 执行完成并且阻塞后续代码，当 promise 被 resolve 后继续执行，需要使用 try catch 来捕获 reject 抛出的错误。也可以把异步的逻辑当为同步的操作来书写。</li></ul> <h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <ul><li>创建对象
<ul><li>字面量：不适合大量创建时使用</li> <li>工厂模式</li> <li>构造函数模式</li> <li>原型模式</li> <li>组合使用构造函数模式和原型模式</li> <li>动态原型模式</li> <li>寄生构造函数模式</li></ul></li> <li>对象的继承
<ul><li>原型链继承</li> <li>借助构造函数继承</li> <li>组合继承</li> <li>原型式继承</li> <li>寄生式继承</li> <li>寄生式组合继承</li></ul></li></ul> <h2 id="es6-有什么更新"><a href="#es6-有什么更新" class="header-anchor">#</a> ES6 有什么更新</h2> <p>ES6 全称 ECMAScript6，指的是 2015 年发布的新一代 JavaScript 标准，一般也泛指包括 2015 年以后发布的所有新标准。</p> <ul><li>新增的 BigInt symbol 类型</li> <li><strong>let、const</strong></li> <li><strong>解构赋值</strong></li> <li><strong>模版字符串</strong></li> <li><strong>for of 遍历迭代器</strong></li> <li>新增的字符串方法
<ul><li>includes()</li> <li>startsWith()</li> <li>endsWith()</li> <li>repeat()</li> <li>padStart()</li> <li>padEnd()</li> <li>trimStart()</li> <li>trimEnd()</li> <li>replaceAll()</li></ul></li> <li>数值的扩展
<ul><li>数值分隔符</li> <li>Number.isFinite()</li> <li>Number.isNaN()</li> <li>Number.parseInt(), Number.parseFloat()</li> <li>Number.isInteger()</li> <li>Number.EPSILON</li></ul></li> <li>函数的扩展
<ul><li><strong>参数的默认值</strong></li> <li><strong>rest 参数</strong></li> <li>name 属性</li> <li><strong>箭头函数</strong></li> <li>尾调用优化</li> <li>catch 参数可省略</li></ul></li> <li>数组的扩展
<ul><li><strong>扩展运算符</strong> <code>...</code></li> <li>Array.from</li> <li>find()</li> <li>findIndex()</li> <li>fill()</li> <li><strong>includes()</strong></li></ul></li> <li>对象的扩展
<ul><li><strong>属性与变量同名时可以简写</strong></li> <li>属性是函数时，可以省略 <code>:function</code></li> <li>属性名表达式</li> <li>super 关键字</li> <li>新增的方法
<ul><li>Object.is()</li> <li><strong>Object.assign()</strong></li> <li>Object.getOwnPropertyDescriptors()</li> <li>Object.getPrototypeOf()</li> <li>Object.setPrototypeOf()</li> <li>Object.create()</li> <li>Object.keys()</li> <li>Object.values()</li> <li>Object.entries()</li> <li>Object.fromEntries()</li></ul></li></ul></li> <li>运算符扩展
<ul><li>指数运算符 **</li> <li><strong>链判断运算符</strong> <code>?.</code></li> <li><strong>Null 判断运算符</strong> <code>??</code></li></ul></li> <li>Set WeakSet</li> <li>Map WeakMap</li> <li><strong>Proxy</strong></li> <li>Reflect</li> <li><strong>Promise</strong></li> <li><strong>async 函数</strong></li> <li>Iterator 和 for...of 循环</li> <li>Generator 函数</li> <li>Class</li> <li><strong>Module</strong> <ul><li>import from</li> <li>import()</li> <li>export</li> <li>export default</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">3/17/2022, 10:38:25 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/notes/assets/js/app.050c2602.js" defer></script><script src="/notes/assets/js/2.92902693.js" defer></script><script src="/notes/assets/js/10.f7e917bf.js" defer></script>
  </body>
</html>
